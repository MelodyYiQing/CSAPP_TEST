/*Segment fault of array 
Because the compiler can not detect the problem of the stack overflow,so when we enter the arguments,we should be really careful.
In this case 1073741824 is a really big number,and we only prepare 2 int to accommodate it.
So if the argument goes beyond 2, the number will wash out the double 3.14.
And when the argument goes bigger,it will wash out our return address then the program will commit alarm.
And some time when we enter 1 there's nothing wrong that is because the compiler always make the space a little larger then our declaration for prepration in case.*/

#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int a[2];             //int a[] first enter into stack. Here is the promblem.a[] is at the upper. 
    double d;             //double d then enter the stack
} struct_t;

double fun(int i) {
    volatile struct_t s;
    s.d = 3.14;
    s.a[i] = 1073741824; /* Possibly out of bounds */    
    return s.d; /* Should be 3.14 */
}

int main(int argc, char *argv[]) {
    int i = 0;
    if (argc >= 2)
	i = atoi(argv[1]);
    double d = fun(i);
    printf("fun(%d) --> %.10f\n", i, d);
    return 0;
}

/*
gec@ubuntu:/mnt/hgfs/share/csapp_code$ ./a.out 0
fun(0) --> 3.1400000000
gec@ubuntu:/mnt/hgfs/share/csapp_code$ ./a.out 1
fun(1) --> 3.1400000000
gec@ubuntu:/mnt/hgfs/share/csapp_code$ ./a.out 2
fun(2) --> 3.1399998665
gec@ubuntu:/mnt/hgfs/share/csapp_code$ ./a.out 3
fun(3) --> 2.0000006104
gec@ubuntu:/mnt/hgfs/share/csapp_code$ ./a.out 4
fun(4) --> 3.1400000000
段错误 (核心已转储)

*/
